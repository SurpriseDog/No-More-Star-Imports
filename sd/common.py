#!/usr/bin/python3
# An autogenerated selection of SurpriseDog's common functions relevant to this project.
# To see how this file was created visit: https://github.com/SurpriseDog/Star-Wrangler
# Written by SurpriseDog at: https://github.com/SurpriseDog

import re
import os
import sys
import math
import time
import json
import subprocess


def json_loader(data):
	try:
		tree = json.loads(data)
	except json.decoder.JSONDecodeError as err:
		print('\n'*5)
		if len(data) > 5000:
			data = data[:5000] + ' ...'
		print('Json Data:', repr(data))
		raise ValueError("Json error", err.__class__.__name__)
	return tree


def search_list(expr, the_list, getfirst=False, func='match', ignorecase=True, searcher=None):
	'''Search for expression in each item in list (or dictionary!)
	getfirst = Return the first value found, otherwise None
	searcher = Custom lamda function'''

	if not searcher:
		# func = dict(search='in').get('search', func)
		# Avoiding regex now in case substring has a regex escape character
		if ignorecase:
			expr = expr.lower()
		if func in ('in', 'search'):
			if ignorecase:
				def searcher(expr, item): 	      # pylint: disable=E0102
					return expr in item.lower()
			else:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return expr in item
		elif func == 'match':
			if ignorecase:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return item.lower().startswith(expr)
			else:
				def searcher(expr, item): 		  # pylint: disable=E0102
					return item.startswith(expr)
		else:
			# Could have nested these, but this is faster.
			raise ValueError("Unknown search type:", func)

	output = []
	for item in the_list:
		if searcher(expr, item):
			if isinstance(the_list, dict):
				output.append(the_list[item])
			else:
				output.append(item)
			if getfirst:
				return output[0]
	return output


def flatten(tree):
	"Flatten a nested list, tuple or dict of any depth into a flat list"
	# For big data sets use this: https://stackoverflow.com/a/45323085/11343425
	out = []
	if isinstance(tree, dict):
		for key, val in tree.items():
			if type(val) in (list, tuple, dict):
				out += flatten(val)
			else:
				out.append({key: val})

	else:
		for item in tree:
			if type(item) in (list, tuple, dict):
				out += flatten(item)
			else:
				out.append(item)
	return out


def quickrun(*cmd, check=False, encoding='utf-8', errors='replace', mode='w', input=None,	# pylint: disable=W0622
			 verbose=0, testing=False, ofile=None, trifecta=False, hidewarning=False, **kargs):
	'''Run a command, list of commands as arguments or any combination therof and return
	the output is a list of decoded lines.
	check    = if the process exits with a non-zero exit code then quit
	testing  = Print command and don't do anything.
	ofile    = output file
	mode     = output file write mode
	trifecta = return (returncode, stdout, stderr)
	input	 = stdinput (auto converted to bytes)
	'''
	cmd = list(map(str, flatten(cmd)))
	if len(cmd) == 1:
		cmd = cmd[0]

	if testing:
		print("Not running command:", cmd)
		return []

	if verbose:
		print("Running command:", cmd)
		print("               =", ' '.join(cmd))

	if ofile:
		output = open(ofile, mode=mode)
	else:
		output = subprocess.PIPE

	if input:
		if type(input) != bytes:
			input = input.encode()

	#Run the command and get return value
	ret = subprocess.run(cmd, check=check, stdout=output, stderr=output, input=input, **kargs)
	code = ret.returncode
	stdout = ret.stdout.decode(encoding=encoding, errors=errors).splitlines() if ret.stdout else []
	stderr = ret.stderr.decode(encoding=encoding, errors=errors).splitlines() if ret.stderr else []

	if ofile:
		output.close()
		return []

	if trifecta:
		return code, stdout, stderr

	if code and not hidewarning:
		warn("Process returned code:", code)

	if not hidewarning:
		for line in stderr:
			print(line)

	return stdout


def warn(*args, header="\n\nWarning:", delay=1 / 64):
	time.sleep(eprint(*args, header=header, v=2) * delay)


def plural(val, word, multiple=None):
	'''Return value + word with plural ending
	You give plural the multiple version of the word to use or let it try to figure it out.
	https://www.grammarly.com/blog/plural-nouns/
	'''

	def get_word(word):
		word = word.lower()
		vowels = 'aoeiu'

		# Exceptions that have irregular changes
		exceptions = dict(
			child='children',
			goose='geese',
			man='men',
			woman='women',
			tooth='teeth',
			foot='feet',
			mouse='mice',
			person='people',
			dice='dies')
		if word in exceptions:
			return exceptions[word]

		# Game words that don't change ending
		if word in (
				'bison',
				'buffalo',
				'carp',
				'cod',
				'deer',
				'fish',
				'kakapo',
				'neat',
				'pike',
				'salmon',
				'sheep',
				'shrimp',
				'shrimps',
				'squid',
				'trout'):
			return word

		for ending in ('f', 'fe'):
			if word.endswith(ending):
				return word[:-1] + 'ves'

		if word.endswith('us') and len(word) > 4:
			return word[:-2] + 'i'

		if word.endswith('o'):
			if word not in ('photo', 'piano', 'halo'):
				return word + 'es'

		if word.endswith('is'):
			return word[:-2] + 'es'

		if word.endswith('on'):
			return word[:-2] + 'a'

		if word.endswith('y') and word[-2] not in vowels:
			return word[:-1] + 'ies'

		for ending in ('s', 'ss', 'sh', 'ch', 'x', 'z'):
			if word.endswith(ending):
				return word + 'es'

		return word + 's'

	if val == 1:
		return str(val) + ' ' + word
	elif multiple:
		return str(val) + ' ' + multiple
	else:
		replacement = get_word(word)
		if word.title() == word:
			replacement = replacement.title()
		if word.upper() == word:
			replacement = replacement.upper()

		return str(val) + ' ' + replacement


def sig(num, digits=3):
	"Return number formatted for significant digits"
	if num == 0:
		return '0'
	negative = '-' if num < 0 else ''
	num = abs(float(num))
	power = math.log(num, 10)
	if num < 1:
		num = int(10**(-int(power) + digits) * num)
		return negative + '0.' + '0' * -int(power) + str(int(num)).rstrip('0')
	elif power < digits - 1:
		return negative + ('{0:.' + str(digits) + 'g}').format(num)
	else:
		return negative + str(int(num))


def rfs(num, mult=1000, digits=3, order=' KMGTPEZY', suffix='B', space=' '):
	'''A "readable" file size
	mult is the value of a kilobyte in the filesystem. (1000 or 1024)
	order is the name of each level
	suffix is a trailing character (B for Bytes)
	space is the space between '3.14 M' for 3.14 Megabytes

	'''
	if abs(num) < mult:
		return sig(num) + suffix
	# Faster than using math.log:
	for x in range(len(order) - 1, -1, -1):
		magnitude = mult**x
		if abs(num) >= magnitude:
			return sig(num / magnitude, digits) + space + (order[x] + suffix).rstrip()
	return str(num) + suffix		#Never called, but needed for pylint


def mkdir(target, exist_ok=True, **kargs):
	"Make a directory without fuss"
	os.makedirs(target, exist_ok=exist_ok, **kargs)


def samepath(*paths):
	"Are any of these file pathname duplicates?"
	return bool(len({os.path.abspath(path) for path in paths}) != len(paths))


class Eprinter:
	'''Drop in replace to print errors if verbose level higher than setup level
	To replace every print statement type: from common import eprint as print

	eprint(v=-1)    # Normally hidden messages
	eprint(v=0)     # Default level
	eprint(v=1)     # Priority messages
	eprint(v=2)     # Warnings
	eprint(v=3)     # Errors
	'''

	# Setup: eprint = Eprinter(<verbosity level>).eprint
	# Simple setup: from common import eprint
	# Usage: eprint(messages, v=1)

	# Don't forget they must end in 'm'
	BOLD = '\033[1m'
	WARNING = '\x1b[1;33;40m'
	FAIL = '\x1b[0;31;40m'
	END = '\x1b[0m'

	def __init__(self, verbose=0):
		self.level = verbose
		self.history = []

		#If string starts with '\n', look at history to make sure previous newlines don't exist
		self.autonewlines = True

	def newlines(self, num=1):
		"Print the required number of newlines after checking history to make sure they exist."
		lines = sum([1 for line in self.history[-num:] if not line.strip()])
		num -= lines
		if num:
			print('\n' * (num), end='')
		return num


	def eprint(self, *args, v=0, color=None, header=None, **kargs):
		'''Print to stderr
		Custom color example: color='1;33;40'
		More colors: https://stackoverflow.com/a/21786287/11343425
		'''
		verbose = v
		# Will print if verbose >= level
		if verbose < self.level:
			return 0

		if not color:
			if v == 2 and not color:
				color = f"{self.WARNING}"
			if v >= 3 and not color:
				color = f"{self.FAIL}" + f"{self.BOLD}"
		else:
			color = '\x1b[' + color + 'm'

		msg = ' '.join(map(str, args))
		if self.autonewlines:
			match = re.match('^\n*', msg)
			if match:
				num = self.newlines(match.span()[1])
				if num:
					#print('created', num, 'newlines', repr(msg[:64]))
					msg = msg.lstrip('\n')


		self.history += msg.splitlines()
		if len(self.history) > 64:
			self.history = self.history[64:]

		if header:
			msg = header + ' ' + msg
		if color:
			print(color + msg + f"{self.END}", file=sys.stderr, **kargs)
		else:
			print(msg, file=sys.stderr, **kargs)
		return len(msg)


def error(*args, header='\nError:', err=RuntimeError, **kargs):
	eprint(*args, header=header, v=3, **kargs)
	raise err


def map_nested(func, array):
	"Apply a function to a nested array and return it"
	out = []
	for item in array:
		if type(item) not in (tuple, list):
			out.append(func(item))
		else:
			out.append(map_nested(func, item))
	return out


class DotDict(dict):
	'''
	Example:
	m = dotdict({'first_name': 'Eduardo'}, last_name='Pool', age=24, sports=['Soccer'])

	Modified from:
	https://stackoverflow.com/questions/2352181/how-to-use-a-dot-to-access-members-of-dictionary
	to set unlimited chained .variables like DotDict().tom.bob = 3
	'''

	def __init__(self, *args, **kwargs):
		super(DotDict, self).__init__(*args, **kwargs)
		for arg in args:
			if isinstance(arg, dict):
				for k, v in arg.items():
					self[k] = v

		if kwargs:
			for k, v in kwargs.items():
				self[k] = v

	def __getattr__(self, attr):
		if attr in self:
			return self.get(attr)
		else:
			self[attr] = DotDict()
			return self[attr]

	def __setattr__(self, key, value):
		self.__setitem__(key, value)

	def __contains__(self, key):
		return bool(key in self.__dict__)

	def __setitem__(self, key, value):
		super(DotDict, self).__setitem__(key, value)
		self.__dict__.update({key: value})

	def __delattr__(self, item):
		self.__delitem__(item)

	def __delitem__(self, key):
		super(DotDict, self).__delitem__(key)
		del self.__dict__[key]


def list_get(lis, index, default=''):

	# Fetch a value from a list if it exists, otherwise return default
	# Now accepts negative indexes
	length = len(lis)
	if -length <= index < length:
		return lis[index]
	else:
		return default


def sort_array(array, *columns, **kargs):
	'''Sort an array by an arbitrary number of columns
	Specify most important column first or leave blank to go left to right
	Starting with Python 2.3, the sort() method is guaranteed to be stable.
	https://docs.python.org/2/library/stdtypes.html#index-29
	'''
	if not array:
		return array
	if not columns:
		columns = list(range(len(array[0])))
	for col in reversed(columns):
		array.sort(key=lambda x: x[col], **kargs)


def query(*question, confirmation='', negation=''):
	'''Ask the user a question. They can type y Y yes Yes and so on.
	Return True if yes, False if No
	If confirmation is passed, then the user must type the same word as confirmation to return True
	If negation is passed user can type the negation word to return False'''

	if not question:
		question = ("Continue?",)
	msg = ' '.join(question)

	while True:
		response = input(msg + ' ')
		response = response.strip().lower()
		if not response:
			continue

		# Have user confirm
		if response and confirmation:
			if response == confirmation.strip().lower():
				return True
			if negation:
				if response == negation.strip().lower():
					return False
				else:
					continue
			else:
				return False

		# Convert response to a single letter y or n
		if response:
			response = response[0]
			if response == 'y':
				return True
			elif response == 'n':
				return False


def str_insert(string, index, sub):
	#return string[:index] + sub + string[index:]
	return ''.join((string[:index], sub, string[index:]))


eprint = Eprinter(verbose=1).eprint     # pylint: disable=C0103

'''
&&&&%%%%%&@@@@&&&%%%%##%%%#%%&@@&&&&%%%%%%/%&&%%%%%%%%%%%&&&%%%%%&&&@@@@&%%%%%%%
%%%%%%%%&@&(((((#%%&%%%%%%%%%&@@&&&&&&%%%&&&&&%%%%%%%%%%%&&&&%&%#((((/#@@%%%%%%%
&&%%%%%%&@(*,,,,,,,/%&%%%%%%%&@@&&&&&%%&&&&%%&&%%%%%%%%%%&&&%#*,,,,,,*/&@&%%%%%%
%%%%%%%&@&/*,,,*,*,,*/%&%%%%%&@@&&&&&&%%&&&&&&&%%%%%%&%%%&&%*,,,,,,,,**#@&&%%%%%
&&&&&%%&@#(**********,*(#&%%%&@&&&&%%%%%%%%%&&&%%%%%%&%&&#*****,*******#@&&%%%%%
&&&%%%&&#/***/*****/*,**,*%&%&@@&&&&&&&&&&&&&&&%%%%%%&&#*,,,*/******/***(%&%%%%%
&&&%%%&%/*****///////**,,,,*/%%&&@@@@@@@@@@@@@@@@&&%#*,,,*,*(///////*****#%&%%%%
@@&%%#&#/,,,*/(//((((//**,,*/#&@@@@@&&&&&&&&&&@@@@@%(/*,,**/(/(((/(//*,,*(&&%%%%
&&&%##&#*,,,*////((((/*///(&@&@@&&&#%((//(/###%&@&@@@@#//**//(#(///***,.,/&&%%%%
%%%%%#%#*,,,**////(///((#&&&%@&%%(/*,,......,,/(#%&&&@@@%((/(/#(///**,,,,(&%%%%%
&&%%%#%%/,..***//(#(#%%&@@@&@%(*.,,..       ...,.,/#@&@@@&&%#(((///**,..,#%%%%%%
%&%%%%%#*,****/(##&@@@&@@@@&%*,....           ....,,(&@@@@@@&@&%((//****,(%%%%%%
%&%%%%%#/,**/#&@@@&@@@@@@@&(*,......    .     ..,..,.(&@@@@@@@&@@@&%#**,*(%%%%%%
&&%%%%#&#(#&@@@&@@@@@@@@%((#@@%&&((,,,,,..,,(**(%@@&@%##(&@@@@@@@@&&@@%#(%%%%%%%
&&&%%%%%&&&&&&@@@@@@%###%@(,%&/@@&(%(/*,..,*/%##&&,%@(*&@#((%&@@@@@@&&@&%%%%&&%%
&&%%%%%%&&&@@@@@@@@#((*#@%,#%%&@#%(/**//,****/(#%%%&&%*(@@*/#(&@@@@@@@&&%%%%%%%%
&&&%%%%%&@@@@&%#/,,,,*,(/%&@@&((%(*,*,,*,**,,*,*#%(#@@&%((**,,,,*#(%&@@&&%%%%%%%
&&&%%%%%@@@@%*/*,...,*,,/*#(//#****,***********,**/#/##(/*,*,...,*/*/&@@&%%&%%%%
&&%%%%%%&@@@(//,....,,*/****/,,/**************/***/,,//**/**,....,*//&@@&%%&%%%%
&&&%%%%%&@@%(/*,. ...,****/*/(//*%&@@&%%%%%%&&&&//*/(*/**/**......,/*#&@&%&&&&%%
&&%%%%%%&@@%(**,,....,/**/((/,#&&&&&%#((((((%&&&@&%/*/(/**/*,. ..,,*/((#@&&&&&&%
%&%%%%%%&&#(/**,..,,,***/((,./%&%&&&@&(/#((#@@&&&%&%,,/((*,/*,,..,,,///(%&%&&&&&
&&%%%%%%&#,**,.,..,,*(//(/,,.,&&&@#&@@##%(#&@&%%@&&#.,,/(((//*,,..,,**,*&%&&%&&&
&&%##%%%#/**,,,,..,*/((((*...,,#&##%(#%%&%%###%(%&/,.. **((((/,...,,,,**(%%#%%%&
&&%####(**,,,.,,.,,/(/(//*,,..../%&(##%&&&%%(#%&#, .. .**//(/(*,,..,.,,**/((#%%%
&&&%#///*,........,/(((//**,.   ,,(#%%%%%%&#%##**.   ,,*//((((*,........,*//(%%%
%%%%(/**...       .,/(((///*., .,*(#(%%%%%%%%##/*,..,,*///((/*.      .....**/(%%
%%%%#(,..          .,/((/(//****,/(((###%#%(#///**,,**/((/((*,          .,.,(%%%
&&%%%#/*...          ,*/(/(/((%%&#&#(/%./.*%(#%#%#&&(((/(/*,.          ..,**(&%%
&&%%%%(*.....          ..*((/**(#&&&&&&&%%%&%&&&%(/,*/((*..           .,..*(&&%%
&&%%%%&#*.      .        */(#/*,,*/((%#%%%%%((**,.*/(#(/,       .       ,(%&%%&%
%%%%%%&%#//**,..           .**(((*,...,,**,,..*,/((/*,.          ...,,//(#%%%%%%
%%%&&&%(/*,**,..,,.,..       .,,**//**,*,,,*,////*,,.        .,.,...,,,**//#%&%%
%%%&&%#/*,*,.    ...      ..         ...  ,.. .       .       ...   ..,,*/(#%&%%
&&&&&%(((*.*... . .*,.   .           .*%%#(,.          .    .*,. ..,.,,**/(%#&%%

Generated by https://github.com/SurpriseDog/Star-Wrangler
2021-08-17
'''
